# 位操作技巧

这里讨论一些位操作技巧，如果使用得当会有助于提高代码运行效率。

这里假设你已经知道整型数据二进制 [补码]([https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin](https://baike.baidu.com/item/补码/6854613?fr=aladdin)) 表示方式和 [位操作]([https://baike.baidu.com/item/%E4%BD%8D%E6%93%8D%E4%BD%9C/10611735?fr=aladdin](https://baike.baidu.com/item/位操作/10611735?fr=aladdin)) 的基本方式。

## 位运算符

|      例子      |        名称         | 结果                                                         |
| :------------: | :-----------------: | :----------------------------------------------------------- |
| **\$a & \$b**  |    And（按位与）    | 将把 \$a 和 $b 中都为 1 的位设为 1，否则设为 0。             |
| **\$a \| \$b** |    Or（按位或）     | 将把 \$a 和 $b 中任何一个为 1 的位设为 1。                   |
|  **\$a ^ $b**  |   Xor（按位异或）   | 将把 \$a 和 $b 中一个为 1 另一个为 0 的位设为 1(相同的为0，不同的为1) |
|    **~ $a**    |   Not（按位取反）   | 将 $a 中为 0 的位设为 1，反之亦然。                          |
| **\$a << $b**  | Shift left（左移）  | 将 \$a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。    |
| **\$a >> $b**  | Shift right（右移） | 将 \$a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。    |

本文中使用的数字 \$x 是 8 bit 无符号整型，二进制补码表。数 $x 的每一比特位标记为 b7,

b6, b5, b4, b3, b3, b2, b1 和 b0。b7 是符号位，权重最大，b0 权重最小。

## 1. 判断整数的奇偶性

```
(x & 1)
```

```php
if (($x & 1) == 0) {
    // $x 是偶数
} else {
    // $x 是奇数
}
```

只要整数的最后一位比特是 1，那它就是奇数，反之就是偶数。

$x 和 1 与（&）运算，（都是1则设为1），保留了 b0 位，如果 b0 是 1，则是奇数；如果 b0 是 0，则是偶数。

以 整数 23 为例，二进制是 0001 0111，b0是1，将 23 和 1 进行 & 运算:

```php
  0001 0111
& 0000 0001
-----------
  0000 0001    
```

b0 位是 1，因此得到 23 是奇数。

## 2. 测试第 n 位比特

```php
y = x & (1<<n); 
```

前面讨论过了第一位比特测试，这里做了一些改进，可以测试第任意位比特，只要将与运算的1向左平移相应的位数即可。假设向左平移n位，接下来的与运算就是只保留第n位，其它位都清零了。

平移演示

```php
1		  00000001    (same as 1<<0)
1<<1      00000010
1<<2      00000100
1<<3      00001000
1<<4      00010000
1<<5      00100000
1<<6      01000000
1<<7      10000000
```

由上可见，偏移位置是从 0 号位开始的

举例，123 的第三位比特是多少？

可以这样做，123 & (1<<3)

123的二进制位 0111 1011，1<<3 即 1向左移动 3 次，0000 1000

```php
  0111 1011
& 0000 1000
----------- 
  0000 1000    
```

可以看到，结果是 1

## 3. 将第 n 位设为 1

```php
y = x | 1<<n;
```

和前面的技巧一样，只是把与运算（&）换成了或运算（|）。与1进行或运算将参与运算的位置为1，与0进行或运算参与预算的位不变。

假设我们要将 123 的第 2 位比特设为1：

```php
  0111 1011 (123 in binary)
| 0000 0100
-----------
  0111 1111    
```

## 4. 将第 n 位设为 0

```php
y = x & ~(1<<n);
```

这个方法的关键就是~(1<<n)，它将第n位设为0，其它位全部为1。

```php
~1        11111110  (same as ~(1<<0))
~(1<<1)   11111101
~(1<<2)   11111011
~(1<<3)   11110111
~(1<<4)   11101111
~(1<<5)   11011111
~(1<<6)   10111111
~(1<<7)   01111111
```

如，将 123 (0111 1011) 的第 4 位设为 0

```php
  0000 0001
<<4
-----------
  0001 0000
~
-----------
  1110 1111    
& 0111 1011 (123 in binary)     
-----------
  0110 1011   
```

## 5. 将第 n 位取反

```php
y = x ^ (1<<n);
```

这次使用的是异或运算，如果异或运算的两个操作数相同，运算结果是0，两个操作数不同，结果是1。怎样将第n位取反呢？如果第n位比特为1，将它与1进行异或运算结果就是0，如果它是0，那么它与1异或运算的结果就是1。于是这一位就取反了。

如将 123 (0111 1011) 的第 5 位取反

```php
  0111 1011
^ 0010 0000
-----------
  0101 1011    
```

## 6. 将最右边的数值为 1的 bit 位设为 0

```php
y = x & (x - 1);
```

这条语句将从右至左看值为1的比特位置为0。例如：整数 001010**1**0 经过上述操作变成 00101000，整数 000**1**0000 经过操作变成 0，因为只有一个比特位值为 1。

更多的例子：

```php
	01010111    (x)
&   01010110    (x-1)
    --------
    01010110
 
    01011000    (x)
&   01010111    (x-1)
    --------
    01010000
 
    10000000    (x = -128)
&   01111111    (x-1 = 127 (with overflow))
    --------
    00000000
 
    11111111    (x = all bits 1)
&   11111110    (x-1)
    --------
    11111110
 
    00000000    (x = no rightmost 1-bits)
&   11111111    (x-1)
    --------
    00000000
```

观察这些例子你会发现有两种情况：

1、这个数值存在值为1的比特位，减一就会将值为一的比特位右边的低位bit全置为1，自身变成0，再与原来的数与运算，得到的结果就是这一位置为0。

2、这个数值是0，那么没有值为1的比特位，减一造成下溢出，所有比特位全变成1（有符号的整数），全0和全1做与运算结果为0。

举例，将 123 最右边的数值为 1 的 bit 位设为 0

```php
echo decbin(123) . PHP_EOL;
echo decbin(123 & (122));
```

将会输出

```shell
1111011
1111010
```

## 7. 隔离最右边值为 1 的比特位

```php
y = x & (-x)
```

也就是找到一个数的最右边值为1的比特位，将其他位置为0。上面的语句实现的就是这个功能。例如01010**1**00（黑体是最右边值为1的比特位）运算后结果为00000100。

更多的例子：

```php
	10111100  (x)
&   01000100  (-x)
    --------
    00000100
 
    01110000  (x)
&   10010000  (-x)
    --------
    00010000
 
    00000001  (x)
&   11111111  (-x)
    --------
    00000001
 
    10000000  (x = -128)
&   10000000  (-x = -128)
    --------
    10000000
 
    11111111  (x = all bits one)
&   00000001  (-x)
    --------
    00000001
 
    00000000  (x = all bits 0, no rightmost 1-bit)
&   00000000  (-x)
    --------
    00000000
```

这项操作在补码表示的范围内有效，在二进制补码系统中-x表示为-x+1。

我们再分成两种情况来看：

1、存在最右边的值为1的比特位，我们以这位比特位中心（暂时标记为bi），把其它比特分为左右两边，右边的所有比特位都为0（bi-1，…，b0），左边的比特位不知道是啥（bn，…，bi+1）。

好了，现在求-x，首先，将bi变位0，然后将bi-1，…，b0变位1，接着翻转bn，…，bi+1，最后再将所得结果+1。就得到了补码形式的-x。

在+1之前由于bi-1，…，b0位都为1，加一后都为0，直到遇到bi位。

总的来看，计算-x即是翻转bn，…，bi+1位，bi位不变，bi-1，…，b0都变成0。

现在来看x & (-x)就很清楚了，即是将bn，…，bi+1置为0，bi位不变，bi-1，…，b0置为0。

2、不存在值为1的比特位，值为0，0的二进制补码还是0，与运算结果还是0.

**我们严格阐述了这个技巧是正确的。**

## 8. 右传播最右边值为1的比特位

```php
y = x | (x-1)
```

看一下例子就知道是怎么回事了，数01010000经过运算的到，寻找最右边值为1的比特位，然后将这一位右边的所有比特位置为1。

这个技巧有个缺陷，即如果x=0结果全为1。

看一下更多的例子：

```shell
	10111100  (x)
|   10111011  (x-1)
    --------
    10111111
 
    01110111  (x)
|   01110110  (x-1)
    --------
    01110111
 
    00000001  (x)
|   00000000  (x-1)
    --------
    00000001
 
    10000000  (x = -128)
|   01111111  (x-1 = 127)
    --------
    11111111
 
    11111111  (x = -1)
|   11111110  (x-1 = -2)
    --------
    11111111
 
    00000000  (x)
|   11111111  (x-1)
    --------
    11111111

```

尽管不能像前一个技巧那样严格，我们还是来简单证明一下（详细论述浪费大家时间，这也不是学术论文不是）。两种情况，从简单的开始：

1、不存在最右边的值为1的比特位，这种情况x=0，x-1=-1，-1的二进制补码表示为11111111（好像忘了说，我们讨论的数都在8bit范围，也不失一般性），0与11111111或运算结果是11111111（不是想要的结果，但事实很残酷）。

2、存在最右边的值为1的比特位，我们故计重施，还是分成两部分（和前一个例子一样），计算x-1只影响右边的比特位，将bi位置为0，所有右边的置为1。现在将结果x-1与小做或运算，左边部分的比特位不变，bi位还是1，右边的都变成了1。结果就是最右边的值为1的比特位向右传播了。

## 9. 隔离最右边值为0的比特位

```shell
y = ~x & (x+1)
```

和技巧7刚好相反，找到x最右边的值为0的比特位，将其他位置为0，这一位置为1。例如x=10101**0**11（找到黑体的0），运算结果是00000100。

看下面更多的例子：

```shell
	10111100  (x)
    --------
    01000011  (~x)
&   10111101  (x+1)
    --------
    00000001
 
    01110111  (x)
    --------
    10001000  (~x)
&   01111000  (x+1)
    --------
    00001000
 
    00000001  (x)
    --------
    11111110  (~x)
&   00000010  (x+1)
    --------
    00000010
 
    10000000  (x = -128)
    --------
    01111111  (~x)
&   10000001  (x+1)
    --------
    00000001
 
    11111111  (x = no rightmost 0-bit)
    --------
    00000000  (~x)
&   00000000  (x+1)
    --------
    00000000
 
    00000000  (x)
    --------
    11111111  (~x)
&   00000001  (x+1)
    --------
    00000001
```

简单证明：假设存在最右边值为0的比特位，那么-x和x+1将这一位变位1，-x和x+1的与运算将左边部分的比特位置为0（-x将x左边部分取反），右边部分运算结果也为0（x+1将x右边部分变位0），因此只剩下bi位为1。

## 10. 将最右边值为0的比特取反

```shell
y = x | (x+1)
```

例如x=10100011运算后结果为10100111。

更多的例子：

```shell
  10111100  (x)
|   10111101  (x+1)
    --------
    10111101
 
    01110111  (x)
|   01111000  (x+1)
    --------
    01111111
 
    00000001  (x)
|   00000010  (x+1)
    --------
    00000011
 
    10000000  (x = -128)
|   10000001  (x+1)
    --------
    10000001
 
    11111111  (x = no rightmost 0-bit)
|   00000000  (x+1)
    --------
    11111111
 
    00000000  (x)
|   00000001  (x+1)
    --------
    00000001
```

事实上，x和x+1进行或运算并不丢失任何信息，将x加1只是填充了最右边的一个0，结果是max{x，x+1}。当x+1溢出时，结果是0，x并没有值为0的比特位，如果没有溢出结果就是x+1，或运算后最右边的0比特被置为1。