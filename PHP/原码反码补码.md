# 原码、反码、补码

**整数在计算机内部都是以「补码」形式存储的**。记住这点，对于整数的处理，会很有帮助。



# 原码

数字在自然界中抽象出来的时候，一棵树，两只猪，是没有正数和负数的概念的。

计算机保存最原始的数字，也是没有正和负的数字，叫没符号数字

如果我们在内存分配4位（bit）去存放无符号数字，是下面这样子的

![8973a6c2bc54026ff2761b71ae1ef827_hd](https://tva1.sinaimg.cn/large/006y8mN6ly1g824fn00qaj305c04ldfr.jpg)

后来在生活中为了表示“欠别人钱”这个概念，就从无符号数中，划分出了“正数”和“负数”

正如上帝一挥手，从混沌中划分了「白天」与 「黑夜」

为了表示正与负，**人们发明了『原码』，把生活应该有的正负概念，原原本本的表示出来**

把左边第一位腾出位置，存放符号，正用 0 来表示，负用 1 来表示

![596846625e45f9727da1defbbff22317_hd](https://tva1.sinaimg.cn/large/006y8mN6ly1g824h0q2suj305u062glo.jpg)

# 反码

加减乘除是最基础的运算，要设计的尽量简单，人脑可以分辨出第一位是『符号位』，但是计算机辨别 『符号位』显然会让计算机的基础电路设计变得十分复杂。

于是人们想出了将符号位也参与运算的方法。我们知道, 根据运算法则减去一个正数等于加上一个负数, 

即: 1-1 = 1 + (-1) = 0 , 

所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了。



但使用『原码』储存的方式，方便了看的人类，却苦了计算机

![7cec066778fbb42aa57598d64336f8b8_hd](https://tva1.sinaimg.cn/large/006y8mN6ly1g824ii6zqkj305r01d742.jpg)

我们希望 （+1）和（-1）相加是0，但计算机只能算出 0001+1001=1010 (-2)



这不是我们想要的结果 (╯' - ')╯︵ ┻━┻

另外一个问题，这里有一个（+0）和（-0）

**为了解决「正负相加等于0」的问题，在『原码』的基础上，人们发明了『反码』**

『反码』表示方式是用来处理负数的，符号位置不变，其余位置相反

![891e6b746e9ef18adafc1f478c570326_hd](https://tva1.sinaimg.cn/large/006y8mN6ly1g825io9p4ej30b606ydg4.jpg)

当『原码』变成『反码』时，完美的解决了「正负相加等于0」的问题

过去的（+1）和（-1）相加，变成了0001+1101=1111，刚好反码表示方式中，1111 象征 -0

# 补码

人们总是进益求精，历史遗留下来的问题——  有两个零存在，+0 和 -0

**我们希望只有一个 0，所以发明了『补码』**，同样是针对『负数』做处理的

『补码』的意思是，从原来『反码』的基础上，补充一个新的代码，（+1）

我们的目标是，没有蛀牙（-0）

![d3617d2ceb02f6129c9b41361804cbe2_hd](https://tva1.sinaimg.cn/large/006y8mN6ly1g825ocngiwj30en07j74s.jpg)

有得必有失，在补一位1的时候，要丢掉最高位



我们要处理"反码"中的『-0』,当 1111 再补上一个 1 之后，变成了 10000，丢掉最高位就是 0000，刚好和左边正数的 0，完美融合掉了

这样就解决了 +0 和 -0 同时存在的问题

另外「正负数相加等于 0」的问题，同样得到满足

举例，3和（-3）相加，0011 + 1101 =10000，丢掉最高位，就是 0000（0）



因此为了运算方面，**整数在计算机内部都是以「补码」形式存储的**。

# 总结

**整数在计算机内部都是以「补码」形式存储的**。



正数的『原码』、『反码』、『补码』都一样

```
3 = [0000 0011]原码 = [0000 0011]反码 = [0000 0011]补码
```

负数：

『反码』= 『原码』除符号位外取反

『补码』= 『反码』+ 1 

```
-3 = [1000 0011]原码 = [1111 1100]反码 = [1111 1101]补码
```